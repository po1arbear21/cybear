m4_include(util/macro.f90.inc)

module gauss_test_m

  use mpfr_m,   only: mpfr, mpfr_startup, mpfr_cleanup, mpfr_cleanup_cache, add, sub, mul, sqr, fma, fms, fmma, fmms, div, neg, pow, log1p_mpfr => log1p, sqrt_mpfr
  use lapack95, only: stev

  implicit none

  private
  public generate_gauss_legendre, generate_gauss_weighted

  type mpfr_vars
    integer                 :: NGS
    integer                 :: MAXN
    type(mpfr), allocatable :: s(:)
    type(mpfr), allocatable :: sg(:,:)
    type(mpfr)              :: x, ix
    type(mpfr)              :: ss
    type(mpfr)              :: b, c, d, t, u
    type(mpfr), allocatable :: aa(:), bb(:), cc(:), v(:)
  contains
    procedure :: init     => mpfr_vars_init
    procedure :: destruct => mpfr_vars_destruct
  end type

contains

  subroutine mpfr_vars_init(this, NGS)
    !! allocate memory for MPFR variables
    class(mpfr_vars), intent(out) :: this
    integer,          intent(in)  :: NGS
      !! number of gauss nodes

    integer :: i, j, n, MAXN

    MAXN = 2 * NGS - 1

    this%NGS  = NGS
    this%MAXN = MAXN

    allocate (this%s(0:MAXN), this%sg(NGS,NGS+1), this%aa(NGS), this%bb(NGS-1), this%cc(NGS-1), this%v(NGS))

    do n = 0, MAXN
      call this%s(n)%init()
    end do
    do i = 1, NGS
      do j = i, NGS + 1
        call this%sg(i,j)%init()
      end do
    end do
    call this%x%init()
    call this%ix%init()
    call this%ss%init()
    call this%b%init()
    call this%c%init()
    call this%d%init()
    call this%t%init()
    call this%u%init()
    do i = 1, NGS
      call this%aa(i)%init()
      call this%v(i)%init()
    end do
    do i = 1, NGS-1
      call this%bb(i)%init()
      call this%cc(i)%init()
    end do
  end subroutine

  subroutine mpfr_vars_destruct(this)
    class(mpfr_vars), intent(inout) :: this

    integer :: i, j, n

    do n = 0, this%MAXN
      call this%s(n)%destruct()
    end do
    do i = 1, this%NGS
      do j = i, this%NGS + 1
        call this%sg(i,j)%destruct()
      end do
    end do
    call this%x%destruct()
    call this%ix%destruct()
    call this%ss%destruct()
    call this%b%destruct()
    call this%c%destruct()
    call this%d%destruct()
    call this%t%destruct()
    call this%u%destruct()
    do i = 1, this%NGS
      call this%aa(i)%destruct()
      call this%v(i)%destruct()
    end do
    do i = 1, this%NGS-1
      call this%bb(i)%destruct()
      call this%cc(i)%destruct()
    end do
  end subroutine

  subroutine generate_gauss_legendre(x, w)
    real, intent(out) :: x(:)
    real, intent(out) :: w(:)

    integer         :: NGS, n
    type(mpfr_vars) :: mvars

    NGS = size(x)

    call mpfr_startup(prec = 1024)
    call mvars%init(NGS)

    call mvars%s(0)%set(1.0)
    call mvars%s(1)%set(0.5)
    do n = 2, mvars%MAXN
      call mvars%t%set(real(n+1))
      call div(mvars%s(n), 1, mvars%t)
    end do

    call generate(mvars, x, w)
  end subroutine

  subroutine generate_gauss_weighted(xi0, x, w, s0)
    real, intent(in)  :: xi0
    real, intent(out) :: x(:)
    real, intent(out) :: w(:)
    real, intent(out) :: s0

    integer, parameter :: NP = 64

    integer         :: NGS, MAXN, n, m
    type(mpfr_vars) :: mvars

    NGS = size(x)
    MAXN = 2 * NGS - 1

    call mpfr_startup(prec = 1024)
    call mvars%init(NGS)

    ! s(0) = log1p(1/xi0)
    call mvars%x%set(xi0)
    call div(mvars%ix, 1, mvars%x)
    call log1p_mpfr(mvars%s(0), mvars%ix)
    s0 = mvars%s(0)%to_real()

    if (xi0 <= 2.0) then
      ! x  = (-xi0)**n
      ! ix = (-xi0)**(-n)
      ! ss: sum up to this point
      ! s: (-xi0)**n * ss
      call mvars%ss%set(mvars%s(0))
      call neg(mvars%x, mvars%x)
      call neg(mvars%ix, mvars%ix)

      ! n = 1
      call add(mvars%ss, mvars%ss, mvars%ix)
      call div(mvars%ix, mvars%ix, -xi0)
      call mul(mvars%s(1), mvars%x, mvars%ss)

      ! rest
      do n = 2, MAXN
        call div(mvars%t, mvars%ix, n)
        call add(mvars%ss, mvars%ss, mvars%t)
        call div(mvars%ix, mvars%ix, -xi0)
        call mul(mvars%x, mvars%x, -xi0)
        call mul(mvars%s(n), mvars%x, mvars%ss)
      end do
    else
      ! "Convergence Acceleration of Alternating Series", Cohen et al.
      call mvars%d%set(8)
      call sqrt_mpfr(mvars%d, mvars%d)
      call add(mvars%d, mvars%d, 3)
      call pow(mvars%d, mvars%d, NP)
      call div(mvars%t, 1, mvars%d)
      call add(mvars%d, mvars%d, mvars%t)
      call mul(mvars%d, mvars%d, 0.5)
      call mvars%b%set(-1)
      call neg(mvars%c, mvars%d)
      do n = 1, MAXN
        call mvars%s(n)%set(0)
      end do
      do m = 0, NP - 1
        call sub(mvars%c, mvars%b, mvars%c)
        do n = 1, MAXN
          call div(mvars%t, mvars%c, n + m + 1)               ! t = c / (n + m + 1)
          call fma(mvars%s(n), mvars%t, mvars%ix, mvars%s(n)) ! s(n) = s(n) + c * ix / (n + m + 1)
        end do
        call div(mvars%ix, mvars%ix, xi0)
        call mul(mvars%b, mvars%b, (m + NP) * (m - NP))
        call div(mvars%b, mvars%b, (m + 0.5) * (m + 1))
      end do
      do n = 1, MAXN
        call div( mvars%s(n),  mvars%s(n), mvars%d)
      end do
    end if

    call generate(mvars, x, w)
  end subroutine

  subroutine generate(mvars, x, w)
    !! generate gauss quadrature rule
    type(mpfr_vars),    intent(inout) :: mvars
      !! MPFR temporary values (with precalculated moments)
    real,               intent(out)   :: x(:)
      !! output gauss node positions
    real,               intent(out)   :: w(:)
      !! output gauss weigmts

    real, parameter :: TOL = 1e-16

    integer :: i, j, k, NGS
    real    :: b(mvars%NGS-1), v(mvars%NGS,mvars%NGS)

    NGS = mvars%NGS

    do i = 1, NGS
      do j = i, NGS + 1
        call mvars%sg(i,j)%set(0)
        do k = 1, i - 1
          call mul(mvars%t, mvars%sg(k,i), mvars%sg(k,j)) ! t = sg(k,i) * sg(k,j)
          call div(mvars%t, mvars%t, mvars%sg(k,k))       ! t = sg(k,i) * sg(k,j) / sg(k,k)
          call add(mvars%sg(i,j), mvars%sg(i,j), mvars%t) ! sg(i,j) = sg(i,j) + sg(k,i) * sg(k,j) / sg(k,k)
        end do

        ! sg(i,j) = s(i+j-2) - sg(i,j)
        call sub(mvars%sg(i,j), mvars%s(i+j-2), mvars%sg(i,j))
      end do
    end do

    call mvars%t%set(0)
    do i = 1, NGS
      ! c_i = sg(i,i+1) / sg(i,i)
      call div(mvars%c, mvars%sg(i,i+1), mvars%sg(i,i))

      ! a(i) = c_i - c_{i-1} =  c - t
      call add(mvars%t, mvars%t,  mvars%c)
      call mvars%aa(i)%set(mvars%t)
      call neg(mvars%t,  mvars%c)
    end do

    do i = 1, NGS-1
      ! c_i = sg(i+1,i+1) / sg(i,i)
      call div(mvars%c, mvars%sg(i+1,i+1), mvars%sg(i,i))

      ! b_i = sqrt(c_i)
      call sqrt_mpfr(mvars%bb(i), mvars%c)
    end do

    ! approximate matrix
    do i = 1, NGS-1
      x(i) = mvars%aa(i)%to_real()
      b(i) = mvars%bb(i)%to_real()
    end do
    x(NGS) = mvars%aa(NGS)%to_real()

    if (NGS == 1) then
      w(1) = 1
      return
    end if

    ! solve symmetric tridiagonal eigenvalue problem with LAPACK (x and b are overwritten)
    call stev(x, b, v)

    ! refine using single Rayleigh quotient iteration step (multiprecision)
    do j = 1, NGS
      ! load estimate
      call mvars%x%set(x(j))
      do i = 1, NGS
        call mvars%v(i)%set(v(i,j))
      end do

      ! forward substitution
      call sub(mvars%t, mvars%aa(1), mvars%x)     ! t = a(1) - x
      call div(mvars%t, 1.0, mvars%t)             ! t = 1 / (a(1) - x)
      call mul(mvars%cc(1), mvars%bb(1), mvars%t) ! c(1) = b(1) / (a(1) - x)
      call mul(mvars%v( 1), mvars%v( 1), mvars%t) ! v(1) = v(1) / (a(1) - x)
      do i = 2, NGS-1
        call sub(mvars%t, mvars%aa(i), mvars%x)                    ! t = a(i) - x
        call fms(mvars%t, mvars%bb(i-1), mvars%cc(i-1), mvars%t)   ! t = b(i-1) * c(i-1) - (a(i) - x)
        call div(mvars%t, 1.0, mvars%t)                            ! t = 1 / (b(i-1) * c(i-1) - (a(i) - x))
        call mul(mvars%cc(i), mvars%bb(i), mvars%t)                ! c(i) = b(i) / (b(i-1) * c(i-1) - (a(i) - x))
        call neg(mvars%cc(i), mvars%cc(i))                         ! c(i) = b(i) / (a(i) - x - b(i-1) * c(i-1))
        call fms(mvars%u, mvars%bb(i-1), mvars%v(i-1), mvars%v(i)) ! u = b(i-1) * v(i-1) - v(i)
        call mul(mvars%v(i), mvars%u, mvars%t)                     ! v(i) = (v(i) - b(i-1) * v(i-1)) / (a(i) - x - b(i-1) * c(i-1))
      end do
      call sub(mvars%t, mvars%aa(NGS), mvars%x)                        ! t = a(N) - x
      call fms(mvars%t, mvars%bb(NGS-1), mvars%cc(NGS-1), mvars%t)     ! t = b(N-1) * c(N-1) - (a(N) - x)
      call fms(mvars%u, mvars%bb(NGS-1), mvars%v(NGS-1), mvars%v(NGS)) ! u = b(N-1) * v(N-1) - v(N)
      call div(mvars%v(NGS), mvars%u, mvars%t)                         ! v(N) = (v(N) - b(N-1) * v(N-1)) / (a(N) - x - b(N-1) * c(N-1))

      ! back substitution
      do i = NGS-1, 1, -1
        call fms(mvars%v(i), mvars%cc(i), mvars%v(i+1), mvars%v(i)) ! v(i) = c(i) * v(i+1) - v(i)
        call neg(mvars%v(i), mvars%v(i))                            ! v(i) = v(i) - c(i) * v(i+1)
      end do

      ! normalization
      call mvars%t%set(0.0)
      do i = 1, NGS
        call sqr(mvars%u, mvars%v(i))
        call add(mvars%t, mvars%t, mvars%u)
      end do
      call sqrt_mpfr(mvars%t, mvars%t)
      do i = 1, NGS
        call div(mvars%v(i), mvars%v(i), mvars%t)
      end do

      ! improve eigenvalue estimate
      call fmma(mvars%t, mvars%aa(1), mvars%v(1), mvars%bb(1), mvars%v(2)) ! t = a(1) * v(1) + b(1) * v(2)
      call mul(mvars%x, mvars%v(1), mvars%t)                               ! x = v(1) * (a(1) * v(1) + b(1) * v(2))
      do i = 2, NGS-1
        call fmma(mvars%t, mvars%bb(i-1), mvars%v(i-1), mvars%aa(i), mvars%v(i)) ! t = b(i-1) * v(i-1) + a(i) * v(i)
        call fma(mvars%t, mvars%bb(i), mvars%v(i+1), mvars%t)                    ! t = b(i-1) * v(i-1) + a(i) * v(i) + b(i) * v(i+1)
        call fma(mvars%x, mvars%v(i), mvars%t, mvars%x)                         ! x = x + v(i) * (b(i-1) * v(i-1) + a(i) * v(i) + b(i) * v(i+1))
      end do
      call fmma(mvars%t, mvars%bb(NGS-1), mvars%v(NGS-1), mvars%aa(NGS), mvars%v(NGS)) ! t = b(N-1) * v(N-1) + a(N) * v(N)
      call fma(mvars%x, mvars%v(NGS), mvars%t, mvars%x)                                ! x = x + v(N) * (b(N-1) * v(N-1) + a(N) * v(N))

      ! convert to real
      x(j) = mvars%x%to_real()

      ! extract weight w = v(1)**2  (s(0) not included)
      call sqr(mvars%t, mvars%v(1))
      w(j) = mvars%t%to_real()
    end do
  end subroutine

end module
