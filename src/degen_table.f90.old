m4_include(util/macro.f90.inc)

module degen_table_m

  use bin_search_m,    only: bin_search, BS_LESS
  use error_m,         only: assert_failed, program_error
  use distributions_m, only: fermi_dirac_integral_1h, fermi_dirac_integral_m1h, inv_fermi_dirac_integral_1h
  use high_precision_m
  use ieee_arithmetic, only: ieee_is_finite, ieee_next_after
  use lapack95,        only: gesv, stev
  use math_m,          only: expm1, linspace, log1p
  use mpfr_m,          only: mpfr, mpfr_startup, mul, div, sub, sqrt_mpfr
  use radau5_m,        only: ode_options, ode_result, radau5
  use util_m,          only: real2str
  use vector_m,        only: vector_real

  implicit none

  type degen_table
    integer :: Ndpot
    integer :: Ndelta
    integer :: Neta1

    real, allocatable :: dpot(:)
    real, allocatable :: delta(:)
    real, allocatable :: eta1(:)

    real, allocatable :: j(:,:,:)
  contains
    procedure :: init => degen_table_init
    procedure :: get  => degen_table_get

    procedure, private :: get_SG     => degen_table_get_SG
    procedure, private :: get_SGFP   => degen_table_get_SGFP
    procedure, private :: get_interp => degen_table_get_interp
    procedure, private :: get_split  => degen_table_get_split

    procedure, private :: load     => degen_table_load
    procedure, private :: save     => degen_table_save

    procedure, private :: gen       => degen_table_gen
    procedure, private :: gen_axes  => degen_table_gen_axes
    procedure, private :: gen_entry => degen_table_gen_entry
    procedure :: gauss     => degen_table_gauss

    procedure :: debug => degen_table_debug
  end type

  real, parameter :: GAMMA     = sqrt(0.125)
  real, parameter :: ETA_SMALL = -16.0
  real, parameter :: ETA_TINY  = -36.0

  integer, parameter :: NGS  = 21
  integer, parameter :: MAXN = 2 * NGS - 1

  ! real, parameter :: XI_GL(NGS) = [ -0.9061798459386640,-0.5384693101056831,0.0000000000000000,0.5384693101056831,0.9061798459386640 ]
  ! real, parameter :: W_GL( NGS) = [  0.2369268850561891, 0.4786286704993665,0.5688888888888889,0.4786286704993665,0.2369268850561891 ]
  real, parameter :: XI_GL(NGS) = [ &
    -0.9937521706203895, -0.9672268385663063, -0.9200993341504008, &
    -0.8533633645833173, -0.7684399634756779, -0.6671388041974123, &
    -0.5516188358872198, -0.4243421202074388, -0.2880213168024011, &
    -0.1455618541608951,  0.0000000000000000,  0.1455618541608951, &
      0.2880213168024011,  0.4243421202074388,  0.5516188358872198, &
      0.6671388041974123,  0.7684399634756779,  0.8533633645833173, &
      0.9200993341504008,  0.9672268385663063,  0.9937521706203895  &
  ]
  real, parameter :: W_GL(NGS) = [ &
    0.0160172282577743, 0.0369537897708525, 0.0571344254268572, &
    0.0761001136283793, 0.0934444234560339, 0.1087972991671484, &
    0.1218314160537285, 0.1322689386333375, 0.1398873947910731, &
    0.1445244039899700, 0.1460811336496904, 0.1445244039899700, &
    0.1398873947910731, 0.1322689386333375, 0.1218314160537285, &
    0.1087972991671484, 0.0934444234560339, 0.0761001136283793, &
    0.0571344254268572, 0.0369537897708525, 0.0160172282577743  &
  ]

contains

  subroutine degen_table_init(this, Ndpot, max_dpot, min_delta, max_eta1, filename, load)
    !! initialize current lookup table for degenerate case
    class(degen_table), intent(out) :: this
    integer,            intent(in)  :: Ndpot
      !! number of dpot points in table
    real,               intent(in)  :: max_dpot
    !! maximal potential drop (lower bound = 0)
    real,               intent(in)  :: min_delta
    !! minimal delta refinement
    real,               intent(in)  :: max_eta1
      !! maximal eta on left side of edge (must be >= than max_dpot)
    character(*),       intent(in)  :: filename
      !! filename for loading/saving
    logical, optional,  intent(in)  :: load
      !! try to load values from file before regenerating (default: true)

    logical :: load_, status

    ! FIXME: triquadratic element

    ! ! number of points must fit cell structure (each cell has 3 nodes, boundary nodes shared with next cell)
    ! m4_assert(Neta  >= 3)
    ! m4_assert(Ndpot >= 3)
    ! m4_assert(mod(Neta,  2) == 1)
    ! m4_assert(mod(Ndpot, 2) == 1)

    ! ! try to load table from file
    ! load_ = .true.
    ! if (present(load)) load_ = load
    ! if (load_) then
    !   call this%load(Neta, Ndpot, max_eta, max_dpot, min_delta, filename, status)
    !   if (status) return
    ! end if

    call this%gen(Ndpot, max_dpot, min_delta, max_eta1)
    call this%save(filename)
  end subroutine

  subroutine degen_table_get(this, eta, dpot, j, djdeta, djddpot)
    !! lookup current
    class(degen_table), intent(in)  :: this
    real,               intent(in)  :: eta(2)
      !! left/right eta
    real,               intent(in)  :: dpot
      !! normalized potential drop
    real,               intent(out) :: j
      !! output interpolated edge current
    real,               intent(out) :: djdeta(2)
      !! output derivatives of j wrt eta
    real,               intent(out) :: djddpot
      !! output derivatives of j wrt dpot

    ! logical :: flip
    ! real    :: eta_(2), dpot_

    ! ! flip edge direction if potential drop is negative
    ! ! FIXME: flip if positive?
    ! flip = (dpot < 0)
    ! if (flip) then
    !   eta_(1) = eta(2)
    !   eta_(2) = eta(1)
    !   dpot_   = - dpot
    ! else
    !   eta_  = eta
    !   dpot_ = dpot
    ! end if

    ! if (all(eta < ETA_TINY)) then
    !   ! Scharfetter-Gummel
    !   call this%get_SG(eta_, dpot_, j, djdeta, djddpot)
    ! elseif (all(eta < ETA_SMALL)) then
    !   ! Scharfetter-Gummel Fix-Point iteration
    !   call this%get_SGFP(eta_, dpot_, j, djdeta, djddpot)
    ! elseif (all(eta >= ETA_SMALL)) then
    !   ! interpolation
    !   call this%get_interp(eta_, dpot_, j, djdeta, djddpot)
    ! else
    !   ! split edge
    !   call this%get_split(eta_, dpot_, j, djdeta, djddpot)
    ! end if

    ! ! flip edge direction back (dj/ddpot = d(-j)/d(-dpot))
    ! if (flip) then
    !   j      = - j
    !   djdeta = - [djdeta(2), djdeta(1)]
    ! end if
  end subroutine

  subroutine degen_table_get_SG(this, eta, dpot, j, djdeta, djddpot)
    use math_m, only: ber, dberdx

    !! Scharfetter-Gummel Current
    class(degen_table), intent(in)  :: this
    real,               intent(in)  :: eta(2)
      !! left/right eta
    real,               intent(in)  :: dpot
      !! normalized potential drop
    real,               intent(out) :: j
      !! output interpolated edge current
    real,               intent(out) :: djdeta(2)
      !! output derivatives of j wrt eta
    real,               intent(out) :: djddpot
      !! output derivatives of j wrt dpot

    real :: B1, B2, dB1, dB2, n(2)

    m4_ignore(this)

    B1  = ber(    dpot)
    B2  = ber(   -dpot)
    dB1 = dberdx( dpot)
    dB2 = dberdx(-dpot)

    n         = exp(eta)
    j         =   B2 * n(1) - B1 * n(2)
    djdeta(1) =   B2 * n(1)
    djdeta(2) = - B1 * n(2)
    djddpot   = - dB2 * n(1) - dB1 * n(2)
  end subroutine

  subroutine degen_table_get_SGFP(this, eta, dpot, j, djdeta, djddpot)
    !! Scharfetter-Gummel fixed-point iteration
    class(degen_table), intent(in)  :: this
    real,               intent(in)  :: eta(2)
      !! left/right eta
    real,               intent(in)  :: dpot
      !! normalized potential drop
    real,               intent(out) :: j
      !! output interpolated edge current
    real,               intent(out) :: djdeta(2)
      !! output derivatives of j wrt eta
    real,               intent(out) :: djddpot
      !! output derivatives of j wrt dpot

    real :: j0, dpot2, tmp

    ! start with pure Scharfetter-Gummel
    call this%get_SG(eta, dpot, j, djdeta, djddpot)

    ! correction below machine precision?
    if (dpot - GAMMA * j == dpot) return

    ! fixed-point iteration
    j0 = huge(1.0)
    do while (j /= j0)
      j0 = j
      dpot2 = dpot - GAMMA * j
      call this%get_SG(eta, dpot2, j, djdeta, djddpot)
    end do

    ! derivatives
    tmp     = 1 + GAMMA * djddpot
    djdeta  = djdeta  / tmp
    djddpot = djddpot / tmp
  end subroutine

  subroutine degen_table_get_interp(this, eta, dpot, j, djdeta, djddpot)
    !! interpolate current
    class(degen_table), intent(in)  :: this
    real,               intent(in)  :: eta(2)
      !! left/right eta
    real,               intent(in)  :: dpot
      !! normalized potential drop
    real,               intent(out) :: j
      !! output interpolated edge current
    real,               intent(out) :: djdeta(2)
      !! output derivatives of j wrt eta
    real,               intent(out) :: djddpot
      !! output derivatives of j wrt dpot

    ! integer :: ieta(2), jeta(2), idpot, jdpot, l, m, n, lmn
    ! real    :: x, y, z, dx, dy, dz, f(3,3,3), p(27)

    ! ! make sure values are in range
    ! if (eta(1) > this%eta( this%Neta )) call program_error("eta(1) = " // real2str(eta(1)) // "; outside range")
    ! if (eta(2) > this%eta( this%Neta )) call program_error("eta(2) = " // real2str(eta(2)) // "; outside range")
    ! if (dpot   > this%dpot(this%Ndpot)) call program_error("dpot   = " // real2str(dpot  ) // "; outside range")

    ! ! find indices
    ! ieta(1) = bin_search(this%eta,  eta(1), BS_LESS)
    ! ieta(2) = bin_search(this%eta,  eta(2), BS_LESS)
    ! idpot   = bin_search(this%dpot, dpot,   BS_LESS)

    ! ! convert to cell start indices
    ! ieta  = ((ieta  + 1) / 2) * 2 - 1
    ! idpot = ((idpot + 1) / 2) * 2 - 1

    ! ! cell size
    ! dx = this%eta(ieta(1) + 2) - this%eta(ieta(1))
    ! dy = this%eta(ieta(2) + 2) - this%eta(ieta(2))
    ! dz = this%eta(idpot   + 2) - this%eta(idpot)

    ! ! values at nodes
    ! f = this%j(ieta(1):ieta(1)+2,ieta(2):ieta(2)+2,idpot:idpot+2)

    ! ! triquadratic interpolation coefficients (from MATLAB symbolic computation)
    ! p( 1) = f(2,2,2)
    ! p( 2) = -(f(1,2,2) - f(3,2,2))/dx
    ! p( 3) = (2*(f(1,2,2) - 2*f(2,2,2) + f(3,2,2)))/dx**2
    ! p( 4) = -(f(2,1,2) - f(2,3,2))/dy
    ! p( 5) = (f(1,1,2) - f(1,3,2) - f(3,1,2) + f(3,3,2))/(dx*dy)
    ! p( 6) = -(2*(f(1,1,2) - f(1,3,2) - 2*f(2,1,2) + 2*f(2,3,2) + f(3,1,2) - f(3,3,2)))/(dx**2*dy)
    ! p( 7) = (2*(f(2,1,2) - 2*f(2,2,2) + f(2,3,2)))/dy**2
    ! p( 8) = -(2*(f(1,1,2) - 2*f(1,2,2) + f(1,3,2) - f(3,1,2) + 2*f(3,2,2) - f(3,3,2)))/(dx*dy**2)
    ! p( 9) = (4*(f(1,1,2) - 2*f(1,2,2) + f(1,3,2) - 2*f(2,1,2) + 4*f(2,2,2) - 2*f(2,3,2) + f(3,1,2) - 2*f(3,2,2) + f(3,3,2)))/(dx**2*dy**2)
    ! p(10) = -(f(2,2,1) - f(2,2,3))/dz
    ! p(11) = (f(1,2,1) - f(1,2,3) - f(3,2,1) + f(3,2,3))/(dx*dz)
    ! p(12) = -(2*(f(1,2,1) - f(1,2,3) - 2*f(2,2,1) + 2*f(2,2,3) + f(3,2,1) - f(3,2,3)))/(dx**2*dz)
    ! p(13) = (f(2,1,1) - f(2,1,3) - f(2,3,1) + f(2,3,3))/(dy*dz)
    ! p(14) = -(f(1,1,1) - f(1,1,3) - f(1,3,1) + f(1,3,3) - f(3,1,1) + f(3,1,3) + f(3,3,1) - f(3,3,3))/(dx*dy*dz)
    ! p(15) = (2*(f(1,1,1) - f(1,1,3) - f(1,3,1) + f(1,3,3) - 2*f(2,1,1) + 2*f(2,1,3) + 2*f(2,3,1) - 2*f(2,3,3) + f(3,1,1) - f(3,1,3) - f(3,3,1) + f(3,3,3)))/(dx**2*dy*dz)
    ! p(16) = -(2*(f(2,1,1) - f(2,1,3) - 2*f(2,2,1) + 2*f(2,2,3) + f(2,3,1) - f(2,3,3)))/(dy**2*dz)
    ! p(17) = (2*(f(1,1,1) - f(1,1,3) - 2*f(1,2,1) + 2*f(1,2,3) + f(1,3,1) - f(1,3,3) - f(3,1,1) + f(3,1,3) + 2*f(3,2,1) - 2*f(3,2,3) - f(3,3,1) + f(3,3,3)))/(dx*dy**2*dz)
    ! p(18) = -(4*(f(1,1,1) - f(1,1,3) - 2*f(1,2,1) + 2*f(1,2,3) + f(1,3,1) - f(1,3,3) - 2*f(2,1,1) + 2*f(2,1,3) + 4*f(2,2,1) - 4*f(2,2,3) - 2*f(2,3,1) + 2*f(2,3,3) + f(3,1,1) - f(3,1,3) - 2*f(3,2,1) + 2*f(3,2,3) + f(3,3,1) - f(3,3,3)))/(dx**2*dy**2*dz)
    ! p(19) = (2*(f(2,2,1) - 2*f(2,2,2) + f(2,2,3)))/dz**2
    ! p(20) = -(2*(f(1,2,1) - 2*f(1,2,2) + f(1,2,3) - f(3,2,1) + 2*f(3,2,2) - f(3,2,3)))/(dx*dz**2)
    ! p(21) = (4*(f(1,2,1) - 2*f(1,2,2) + f(1,2,3) - 2*f(2,2,1) + 4*f(2,2,2) - 2*f(2,2,3) + f(3,2,1) - 2*f(3,2,2) + f(3,2,3)))/(dx**2*dz**2)
    ! p(22) = -(2*(f(2,1,1) - 2*f(2,1,2) + f(2,1,3) - f(2,3,1) + 2*f(2,3,2) - f(2,3,3)))/(dy*dz**2)
    ! p(23) = (2*(f(1,1,1) - 2*f(1,1,2) + f(1,1,3) - f(1,3,1) + 2*f(1,3,2) - f(1,3,3) - f(3,1,1) + 2*f(3,1,2) - f(3,1,3) + f(3,3,1) - 2*f(3,3,2) + f(3,3,3)))/(dx*dy*dz**2)
    ! p(24) = -(4*(f(1,1,1) - 2*f(1,1,2) + f(1,1,3) - f(1,3,1) + 2*f(1,3,2) - f(1,3,3) - 2*f(2,1,1) + 4*f(2,1,2) - 2*f(2,1,3) + 2*f(2,3,1) - 4*f(2,3,2) + 2*f(2,3,3) + f(3,1,1) - 2*f(3,1,2) + f(3,1,3) - f(3,3,1) + 2*f(3,3,2) - f(3,3,3)))/(dx**2*dy*dz**2)
    ! p(25) = (4*(f(2,1,1) - 2*f(2,1,2) + f(2,1,3) - 2*f(2,2,1) + 4*f(2,2,2) - 2*f(2,2,3) + f(2,3,1) - 2*f(2,3,2) + f(2,3,3)))/(dy**2*dz**2)
    ! p(26) = -(4*(f(1,1,1) - 2*f(1,1,2) + f(1,1,3) - 2*f(1,2,1) + 4*f(1,2,2) - 2*f(1,2,3) + f(1,3,1) - 2*f(1,3,2) + f(1,3,3) - f(3,1,1) + 2*f(3,1,2) - f(3,1,3) + 2*f(3,2,1) - 4*f(3,2,2) + 2*f(3,2,3) - f(3,3,1) + 2*f(3,3,2) - f(3,3,3)))/(dx*dy**2*dz**2)
    ! p(27) = (8*(f(1,1,1) - 2*f(1,1,2) + f(1,1,3) - 2*f(1,2,1) + 4*f(1,2,2) - 2*f(1,2,3) + f(1,3,1) - 2*f(1,3,2) + f(1,3,3) - 2*f(2,1,1) + 4*f(2,1,2) - 2*f(2,1,3) + 4*f(2,2,1) - 8*f(2,2,2) + 4*f(2,2,3) - 2*f(2,3,1) + 4*f(2,3,2) - 2*f(2,3,3) + f(3,1,1) - 2*f(3,1,2) + f(3,1,3) - 2*f(3,2,1) + 4*f(3,2,2) - 2*f(3,2,3) + f(3,3,1) - 2*f(3,3,2) + f(3,3,3)))/(dx**2*dy**2*dz**2)

    ! ! coordinates relative to cell center
    ! x = eta(1) - this%eta( ieta(1) + 1)
    ! y = eta(2) - this%eta( ieta(2) + 1)
    ! z = dpot   - this%dpot(idpot   + 1)

    ! ! reset output
    ! j       = 0
    ! djdeta  = 0
    ! djddpot = 0

    ! ! evaluate polynomial
    ! lmn = 0
    ! do n = 0, 2; do m = 0, 2; do l = 0, 2
    !   lmn = lmn + 1
    !   j = j + p(lmn) * x**l * y**m * z**n
    !   if (l > 0) djdeta(1) = djdeta(1) + p(lmn) * l * x**(l-1) * y**m * z**n
    !   if (m > 0) djdeta(2) = djdeta(2) + p(lmn) * m * y**(m-1) * x**l * z**n
    !   if (n > 0) djddpot   = djddpot   + p(lmn) * n * z**(n-1) * x**l * y**m
    ! end do; end do; end do
  end subroutine

  subroutine degen_table_get_split(this, eta, dpot, j, djdeta, djddpot)
    !! get current by splitting edge
    class(degen_table), intent(in)  :: this
    real,               intent(in)  :: eta(2)
      !! left/right eta
    real,               intent(in)  :: dpot
      !! normalized potential drop
    real,               intent(out) :: j
      !! output interpolated edge current
    real,               intent(out) :: djdeta(2)
      !! output derivatives of j wrt eta
    real,               intent(out) :: djddpot
      !! output derivatives of j wrt dpot

    ! real, parameter :: ATOL = 1e-15

    ! integer :: it
    ! real    :: x, f, dfdx, dfdeta(2), dfddpot, dx, err, dxdeta(2), dxddpot, djdx

    ! ! approximate solution
    ! x = 0.5 ! FIXME: use Scharfetter-Gummel as approximation

    ! ! FIXME: bisection?

    ! ! newton iteration to find splitting position: find x in (0, 1) such that eta(x) = ETA_SMALL
    ! err = huge(1.0)
    ! it = 0
    ! do while (err > ATOL)
    !   it = it + 1

    !   ! get Newton update
    !   call residual(x, f, dfdx, dfdeta, dfddpot)
    !   dx  = - f / dfdx
    !   err = abs(dx)

    !   ! limit update
    !   if (dx < - x) then
    !     dx = - 0.5 * x
    !   end if
    !   if (dx > 1 - x) then
    !     dx = 0.5 * (1 - x)
    !   end if

    !   ! update solution
    !   x = x + dx

    !   print "(I6,2ES25.16E3)", it, x, err ! FIXME: remove
    ! end do

    ! ! implicit differentiation
    ! dxdeta  = - dfdeta  / dfdx
    ! dxddpot = - dfddpot / dfdx

    ! ! evaluate current
    ! call eval_j(x, dxdeta, dxddpot, j, djdeta, djddpot)

  contains

    ! subroutine residual(x, f, dfdx, dfdeta, dfddpot)
    !   !! difference between the current in the left and right part of the edge
    !   real, intent(in)  :: x
    !     !! edge split position (solution variable)
    !   real, intent(out) :: f
    !     !! output residual: j1*(1-x) - j2*x
    !   real, intent(out) :: dfdx
    !     !! output derivative of f wrt x
    !   real, intent(out) :: dfdeta(2)
    !     !! output derivative of f wrt eta
    !   real, intent(out) :: dfddpot
    !     !! output derivative of f wrt dpot

    !   real :: dpot1, dpot2, j1, j2, dj1deta(2), dj2deta(2), dj1ddpot1, dj2ddpot2

    !   ! get current in left part
    !   dpot1 = dpot * x
    !   if (eta(1) <= ETA_SMALL) then
    !     call this%get_SGFP([eta(1), ETA_SMALL], dpot1, j1, dj1deta, dj1ddpot1)
    !   else
    !     call this%get_interp([eta(1), ETA_SMALL], dpot1, j1, dj1deta, dj1ddpot1)
    !   end if

    !   ! get current in right part
    !   dpot2 = dpot * (1 - x)
    !   if (eta(2) <= ETA_SMALL) then
    !     call this%get_SGFP([ETA_SMALL, eta(2)], dpot2, j2, dj2deta, dj2ddpot2)
    !   else
    !     call this%get_interp([ETA_SMALL, eta(2)], dpot2, j2, dj2deta, dj2ddpot2)
    !   end if

    !   ! residual (respect scale)
    !   f         = j1 * (1 - x) - j2 * x
    !   dfdx      = - j1 - j2 + dj1ddpot1 * dpot2 + dj2ddpot2 * dpot1
    !   dfdeta(1) =   dj1deta(1) * (1 - x)
    !   dfdeta(2) = - dj2deta(2) * x
    !   dfddpot   = (dj1ddpot1 - dj2ddpot2) * x * (1 - x)
    ! end subroutine

    ! subroutine eval_j(x, dxdeta, dxddpot, j, djdeta, djddpot)
    !   !! evaluate current after splitting position has been found
    !   real, intent(in)  :: x
    !   real, intent(in)  :: dxdeta(2)
    !   real, intent(in)  :: dxddpot
    !   real, intent(out) :: j
    !   real, intent(out) :: djdeta(2)
    !   real, intent(out) :: djddpot

    !   real :: dpot1, j1, dj1deta(2), dj1ddpot1, dj1dx
    !   real :: dpot2, j2, dj2deta(2), dj2ddpot2, dj2dx

    !   ! evaluate current using longer part of edge (avoid division by small number)
    !   if (x >= 0.5) then
    !     dpot1 = dpot * x
    !     if (eta(1) <= ETA_SMALL) then
    !       call this%get_SGFP([eta(1), ETA_SMALL], dpot1, j1, dj1deta, dj1ddpot1)
    !     else
    !       call this%get_interp([eta(1), ETA_SMALL], dpot1, j1, dj1deta, dj1ddpot1)
    !     end if

    !     j         = j1 / x
    !     dj1dx     = dj1ddpot1 * dpot
    !     djdeta(1) = (dj1deta(1)    + dxdeta(1) * (dj1dx - j)) / x
    !     djdeta(2) = (                dxdeta(2) * (dj1dx - j)) / x
    !     djddpot   = dj1ddpot1      + dxddpot   * (dj1dx - j)  / x
    !   else
    !     dpot2 = dpot * (1 - x)
    !     if (eta(2) <= ETA_SMALL) then
    !       call this%get_SGFP([ETA_SMALL, eta(2)], dpot2, j2, dj2deta, dj2ddpot2)
    !     else
    !       call this%get_interp([ETA_SMALL, eta(2)], dpot2, j2, dj2deta, dj2ddpot2)
    !     end if

    !     j         = j2 / (1 - x)
    !     dj2dx     = - dj2ddpot2 * dpot
    !     djdeta(1) = (             dxdeta(1) * (dj2dx + j)) / (1 - x)
    !     djdeta(2) = (dj2deta(2) + dxdeta(2) * (dj2dx + j)) / (1 - x)
    !     djddpot   = dj2ddpot2   + dxddpot   * (dj2dx + j)  / (1 - x)
    !   end if
    ! end subroutine

  end subroutine

  subroutine degen_table_load(this, Neta, Ndpot, max_eta, max_dpot, min_delta, filename, status)
    !! load lookup table from file
    class(degen_table), intent(out) :: this
    integer,            intent(in)  :: Neta
      !! number of eta points in table
    integer,            intent(in)  :: Ndpot
      !! number of dpot points in table
    real,               intent(in)  :: max_eta
      !! maximal eta (no lower bound)
    real,               intent(in)  :: max_dpot
      !! maximal potential drop (lower bound = 0)
    real,               intent(in)  :: min_delta
      !! minimal delta refinement
    character(*),       intent(in)  :: filename
      !! filename
    logical,            intent(out) :: status
      !! success/fail

    ! integer :: Neta_, Ndpot_, Ndelta_ funit

    ! ! check if file exists
    ! inquire (file = filename, exist = status)
    ! if (.not. status) return

    ! open (newunit = funit, file = filename, status = "old", action = "read", form = "unformatted")

    ! read (funit) Neta_
    ! if (Neta_ /= Neta) goto 100
    ! read (funit) Ndpot_
    ! if (Ndpot_ /= Ndpot) goto 100
    ! read (funit) Ndelta_
    ! if (Ndelta_ /= ?) goto 100

    ! allocate (this%eta(Neta), this%dpot(Ndpot), this%j(Neta,Neta,Ndpot))
    ! read (funit) this%eta
    ! if (this%eta(Neta) /= max_eta) goto 100
    ! read (funit) this%dpot
    ! if (this%dpot(Ndpot) /= max_dpot) goto 100
    ! read (funit) this%delta
    ! if (abs(this%delta(??+1) - this%delta(??))/min_delta - 1 > 1e-15) goto 100
    ! read (funit) this%j

    ! close (funit)
    ! return

    ! 100 close (funit)
    ! status = .false.
    ! return
  end subroutine

  subroutine degen_table_save(this, filename)
    !! save lookup table
    class(degen_table), intent(in) :: this
    character(*),       intent(in)  :: filename
      !! filename

    ! integer :: funit

    ! open (newunit = funit, file = filename, status = "replace", action = "write", form = "unformatted")
    ! write (funit) this%Neta
    ! write (funit) this%Ndpot
    ! write (funit) this%Ndelta
    ! write (funit) this%eta
    ! write (funit) this%dpot
    ! write (funit) this%delta
    ! write (funit) this%j
    ! close (funit)
  end subroutine

  subroutine degen_table_gen(this, Ndpot, max_dpot, min_delta, max_eta1)
    !! generate lookup table
    class(degen_table), intent(inout) :: this
    integer,            intent(in)    :: Ndpot
      !! number of dpot points in table
    real,               intent(in)    :: max_dpot
      !! maximal potential drop (lower bound = 0)
    real,               intent(in)    :: min_delta
      !! minimal delta refinement
    real,               intent(in)    :: max_eta1
      !! maximal eta on left side of edge (must be >= than max_dpot)

    integer           :: ieta1, idelta, idpot, counter
    type(ode_options) :: opt

    ! generate dpot, delta and eta1 axes
    call this%gen_axes(Ndpot, max_dpot, min_delta, max_eta1)
    allocate (this%j(this%Neta1,-this%Ndelta:this%Ndelta,this%Ndpot), source = 0.0)

    ! init ode options
    call opt%init(1, atol = [1e-16], rtol = [5e-15], newton_max_it = 10, max_rejected = 64, min_rx = 1e-14, initial_rx = 1e-4)

    print *, "Ndpot  = ", this%Ndpot
    print *, "Ndelta = ", this%Ndelta

    counter = 0

    !$omp parallel do schedule(dynamic) default(none) private(idpot,idelta,ieta1) shared(this,opt,counter)
    do idpot = 1, this%Ndpot
      ! delta = 0; deta = dpot => j = 0

      ! delta > 0
      do idelta = 1, this%Ndelta
        !$omp atomic
        counter = counter + 1
        !$omp end atomic
        print *, counter, 2 * this%Ndpot * this%Ndelta
        do ieta1 = 1, this%Neta1
          call this%gen_entry(opt, this%dpot(idpot), this%delta(idelta), this%eta1(ieta1), this%j(ieta1,idelta-1,idpot), this%j(ieta1,idelta,idpot))
        end do
      end do

      ! delta < 0
      do idelta = -1, -this%Ndelta, -1
        !$omp atomic
        counter = counter + 1
        !$omp end atomic
        print *, counter, 2 * this%Ndpot * this%Ndelta
        do ieta1 = 1 - idelta, this%Neta1
          call this%gen_entry(opt, this%dpot(idpot), this%delta(idelta), this%eta1(ieta1), this%j(ieta1,idelta+1,idpot), this%j(ieta1,idelta,idpot))
        end do
      end do
    end do
    !$omp end parallel do
  end subroutine

  subroutine degen_table_gen_axes(this, Ndpot, max_dpot, min_delta, max_eta1)
    !! generate delta values (use this%dpot array)
    class(degen_table), intent(inout) :: this
    integer,            intent(in)    :: Ndpot
      !! number of dpot points in table
    real,               intent(in)    :: max_dpot
      !! maximal potential drop (lower bound = 0)
    real,               intent(in)    :: min_delta
      !! minimal delta refinement
    real,               intent(in)    :: max_eta1
      !! maximal eta on left side of edge (must be >= than max_dpot)

    integer           :: Nref
    real              :: d, e, t
    type(vector_real) :: ref

    ! generate dpot
    this%Ndpot = Ndpot
    this%dpot  = linspace(0.0, max_dpot, Ndpot)

    ! generate refinement
    call ref%init(0, c = 32)
    call ref%push(0.0)
    d = (this%dpot(Ndpot) - this%dpot(1)) / (Ndpot - 1)
    e = 1.0
    do while (ref%back() < d)
      t = ref%back() / d
      call ref%push(ref%back() + min_delta * exp(e * t) + (d - min_delta * exp(e)) * expm1(e * t) / expm1(e))
    end do
    Nref = ref%n
    ref%d(1:Nref) = ref%d(1:Nref) * (1 + (d - ref%back()) * ref%d(1:Nref) / ref%back()**2)

    ! delta
    this%Ndelta = Nref + this%Ndpot - 3
    allocate (this%delta(-this%Ndelta:this%Ndelta))
    this%delta(0:Nref-1) = ref%d(1:Nref)
    this%delta(Nref:this%Ndelta) = this%dpot(3:this%Ndpot)
    this%delta(-this%Ndelta:-1) = - this%delta(this%Ndelta:1:-1)

    ! eta1
    if (max_eta1 <= ETA_SMALL + max_dpot) then
      this%eta1 = ETA_SMALL + this%delta(0:this%Ndelta)
    else
      this%eta1 = ETA_SMALL + [this%delta(0:this%Ndelta-1), linspace(max_dpot, max_eta1, 1 + nint((max_eta1 - max_dpot) / d))]
    end if
    this%Neta1 = this%Ndelta + nint((max_eta1 - max_dpot) / d)
  end subroutine

  subroutine degen_table_gen_entry(this, opt, dpot, delta, eta1, j0, j)
    use math_m, only: ber

    !! generate one entry in lookup table
    class(degen_table), intent(in)  :: this
    type(ode_options),  intent(in)  :: opt
      !! ode options
    real,               intent(in)  :: dpot
      !! potential drop
    real,               intent(in)  :: delta
      !! delta = deta - dpot
    real,               intent(in)  :: eta1
      !! eta at left end of edge
    real,               intent(in)  :: j0
      !! start solution
    real,               intent(out) :: j
      !! output edge current

    ! FIXME: Gauss-Legendre instead of Gauss-Lobatto
    real, parameter :: xk(21) = [-1.0, &
      &                          -0.9825722966045480282345, &
      &                          -0.9419762969597455342961, &
      &                          -0.8792947553235904644512, &
      &                          -0.7960019260777124047443, &
      &                          -0.6940510260622232326273, &
      &                          -0.575831960261830686927, &
      &                          -0.4441157832790021011945, &
      &                          -0.3019898565087648872754, &
      &                          -0.1527855158021854660064, &
      &                          0.0, &
      &                          0.1527855158021854660064, &
      &                          0.3019898565087648872754, &
      &                          0.444115783279002101195, &
      &                          0.575831960261830686927, &
      &                          0.6940510260622232326273, &
      &                          0.7960019260777124047443, &
      &                          0.8792947553235904644512, &
      &                          0.9419762969597455342961, &
      &                          0.9825722966045480282345, &
      &                          1.0]
    real, parameter :: wk(21) = [0.004761904761904761904762, &
      &                          0.0291848400985054586095, &
      &                          0.0518431690008496250727, &
      &                          0.0732739181850741442525, &
      &                          0.0929854679578860653011, &
      &                          0.110517083219123335267, &
      &                          0.1254581211908689480152, &
      &                          0.1374584628600413435809, &
      &                          0.1462368624479774592673, &
      &                          0.151587575111681384453, &
      &                          0.1533851903321749485516, &
      &                          0.1515875751116813844533, &
      &                          0.1462368624479774592673, &
      &                          0.1374584628600413435809, &
      &                          0.1254581211908689480152, &
      &                          0.110517083219123335267, &
      &                          0.092985467957886065301, &
      &                          0.0732739181850741442525, &
      &                          0.0518431690008496250727, &
      &                          0.0291848400985054586095, &
      &                          0.004761904761904761904762]

    integer :: dir, it, ik
    real    :: deta, eta(2), e, n(2), nc, jmin, jmax, jsgn, f, fmin, fmax, smin, smax, s, Fm1h, B
    real    :: dfdj, dj, err, err0, atol, rtol, tmp

    m4_ignore(this)

    deta = dpot + delta
    eta(1) = eta1
    eta(2) = eta1 + deta

    ! special case: dpot == 0 => j = - int_{eta1}^{eta2} F12(eta) deta => use Gaussian Quadrature
    if (dpot == 0) then
      j = 0
      do ik = 1, size(xk)
        e = 0.5 * (eta(1) + eta(2)) + 0.5 * (eta(2) - eta(1)) * xk(ik)
        call fermi_dirac_integral_1h(e, f, tmp)
        j = j - 0.5 * deta * wk(ik) * f
      end do
      return
    end if

    ! special case: eta = const => deta/dx = dpot - j / F12(eta) = 0
    if (abs(deta) < 1e-6) then
      call fermi_dirac_integral_1h( eta(1), n(1), tmp)
      call fermi_dirac_integral_m1h(eta(1), Fm1h, tmp)
      B = ber(dpot * Fm1h / n(1))
      j = n(1) * (dpot - deta * B)
      return
    end if

    ! get densities
    call fermi_dirac_integral_1h(eta(1), n(1), tmp)
    call fermi_dirac_integral_1h(eta(2), n(2), tmp)

    ! get jmin, jmax by slope (detadx must be equal to deta for some x in [0, 1])
    jmin = min(n(1), n(2)) * abs(dpot - deta)
    jmax = max(n(1), n(2)) * abs(dpot - deta)
    jsgn = sign(1.0, dpot - deta)
    if (jsgn < 0) then
      ! correct sign and swap jmin, jmax
      tmp  =   jmin
      jmin = - jmax
      jmax = - tmp
    end if

    ! determine shooting direction and reduce j range further if possible
    if (eta(2) < eta(1)) then
      dir = -1
      jmin = max(jmin, dpot * n(1))
    elseif (eta(2) <= eta(1) + dpot) then
      dir = 0
      jmin = max(jmin, 0.0)
      jmax = min(jmax, dpot * n(1))
    else
      dir = +1
      call fermi_dirac_integral_1h(eta(2) - 0.5 * dpot, nc, tmp)
      jmin = max(jmin, - nc * (deta - dpot))
      jmax = min(jmax, 0.0)
    end if

    ! residuals at boundaries
    call residual(jmin, fmin, tmp)
    call residual(jmax, fmax, tmp)
    smin = sign(1.0, fmin)
    smax = sign(1.0, fmax)
    if (smin == smax) then
      if ((fmin == 0) .and. (fmax == 0)) then
        j = 0.5 * (jmin + jmax)
        return
      elseif (fmin == 0) then
        j = jmin
        return
      elseif (fmax == 0) then
        j = jmax
        return
      elseif (abs(fmin) < 0.1 * abs(fmax)) then
        ! widen lower bound
        jmin = jmin - 1e-3 * (jmax - jmin)
        call residual(jmin, fmin, tmp)
        smin = sign(1.0, fmin)
      elseif (abs(fmax) < 0.1 * abs(fmin)) then
        ! widen upper bound
        jmax = jmax + 1e-3 * (jmax - jmin)
        call residual(jmax, fmax, tmp)
        smax = sign(1.0, fmax)
      end if

      if (smin == smax) then
        print "(A)",           "Error:"
        print "(A,ES25.16E3)", "dpot   = ", dpot
        print "(A,ES25.16E3)", "delta  = ", delta
        print "(A,ES25.16E3)", "eta(1) = ", eta(1)
        print "(A,ES25.16E3)", "eta(2) = ", eta(2)
        print "(A,ES25.16E3)", "jmin   = ", jmin
        print "(A,ES25.16E3)", "jmax   = ", jmax
        call program_error("no sign change")
      end if
    end if

    ! start solution
    j = j0

    ! tolerances
    atol = max(1e-15 * (abs(j0)), 1e-250)
    rtol = 1e-13
    err0 = huge(1.0)
    err  = 0.5 * (jmax - jmin)

    ! newton iteration
    it = 0
    do while ((err > atol) .and. (err > abs(j) * rtol))
      it = it + 1

      ! bisection
      if (((j < jmin) .or. (j > jmax) .or. (err0 <= err))) then
        j = 0.5 * (jmin + jmax)
      end if

      ! evaluate residual
      call residual(j, f, dfdj)

      ! newton update
      dj   = - f / dfdj
      err0 = err
      err  = abs(dj)

      ! update bounds
      s = sign(1.0, f)
      if (s * smax > 0) then
        jmax = j
        fmax = f
      else
        jmin = j
        fmin = f
      end if

      ! update solution
      j = j + dj

      ! exit if close to solution
      if (((jmax - jmin) < 0.5 * abs(jmin + jmax) * rtol) .or. (0.5 * (jmax - jmin) < atol)) then
        j = 0.5 * (jmax + jmin)
        exit
      end if
    end do

  contains

    subroutine residual(j, f, dfdj)
      !! shooting method residual
      real, intent(in)  :: j
        !! current (solution variable)
      real, intent(out) :: f
        !! output residual eta(x2) - eta2
      real, intent(out) :: dfdj

      logical          :: status
      real             :: xknee, res1, res2, dres1, dres2
      type(ode_result) :: result1, result2

      if (dir > 0) then
        xknee = 1.0
      elseif (dir < 0) then
        xknee = 0.0
      else
        xknee = (n(1) * n(2) * (deta - dpot) + n(1) * j)/(j * (n(1) - n(2)))
        if (.not. ieee_is_finite(xknee)) xknee = 0.5
      end if

      res1  = eta(1)
      res2  = eta(2)
      dres1 = 0
      dres2 = 0

      if (xknee >= 1) then
        call radau5(detadx, 0.0, 1.0, [1.0], [eta(1)], [j], opt, status, result1)
        if (.not. status) goto 200
        res1  = result1%Usmp(1,1)
        dres1 = result1%dUsmpdP(1,1,1)
      elseif (xknee <= 0) then
        call radau5(detadx, 1.0, 0.0, [0.0], [eta(2)], [j], opt, status, result2)
        if (.not. status) goto 200
        res2  = result2%Usmp(1,1)
        dres2 = result2%dUsmpdP(1,1,1)
      else
        call radau5(detadx, 0.0, xknee, [xknee], [eta(1)], [j], opt, status, result1)
        if (.not. status) goto 200
        call radau5(detadx, 1.0, xknee, [xknee], [eta(2)], [j], opt, status, result2)
        if (.not. status) goto 200
        res1  = result1%Usmp(1,1)
        res2  = result2%Usmp(1,1)
        dres1 = result1%dUsmpdP(1,1,1)
        dres2 = result2%dUsmpdP(1,1,1)
      end if

      f    =  res1 -  res2
      dfdj = dres1 - dres2

      return

      200 print "(A)",       "Error:"
      print "(A,I6)",        "dir    = ", dir
      print "(A,ES25.16E3)", "xknee  = ", xknee
      print "(A,ES25.16E3)", "dpot   = ", dpot
      print "(A,ES25.16E3)", "delta  = ", delta
      print "(A,ES25.16E3)", "eta(1) = ", eta(1)
      print "(A,ES25.16E3)", "eta(2) = ", eta(2)
      print "(A,ES25.16E3)", "j      = ", j
      call program_error("Unable to solve ODE")
    end subroutine

    subroutine detadx(x, U, p, status, f, dfdU, dfdp)
      !! ode right-hand side
      real,           intent(in)  :: x
        !! x coordinate
      real,           intent(in)  :: U(:)
        !! state (eta)
      real,           intent(in)  :: p(:)
        !! parameters (j)
      logical,        intent(out) :: status
        !! success/fail
      real, optional, intent(out) :: f(:)
        !! output deta/dx
      real, optional, intent(out) :: dfdU(:,:)
        !! output derivative of f wrt eta
      real, optional, intent(out) :: dfdp(:,:)
        !! output derivative of f wrt P (ignore)

      real :: F12, dF12

      m4_ignore(x)

      status = .true.

      call fermi_dirac_integral_1h(U(1), F12, dF12)

      if (present(f)) then
        f(1) = dpot - p(1) / F12
      end if
      if (present(dfdU)) then
        dfdU(1,1) = (p(1) * dF12 / F12) / F12
      end if
      if (present(dfdp)) then
        dfdp(1,1) = - 1.0 / F12
      end if
    end subroutine

  end subroutine

  subroutine degen_table_gauss(this, dpot, delta, eta1, xi_prev, w_prev, j_prev, xi, w, j)
    !! generate one entry in lookup table using gauss quadrature
    class(degen_table), intent(in)  :: this
    real,               intent(in)  :: dpot
      !! potential drop
    real,               intent(in)  :: delta
      !! delta = deta - dpot
    real,               intent(in)  :: eta1
      !! eta at left end of edge
    real,               intent(in)  :: xi_prev(:)
      !! previous gauss node positions
    real,               intent(in)  :: w_prev(:)
      !! previous gauss weights
    real,               intent(in)  :: j_prev
      !! previous edge current
    real,               intent(out) :: xi(:)
      !! output new gauss node positions
    real,               intent(out) :: w(:)
      !! output new gauss weights
    real,               intent(out) :: j
      !! output new edge current

    integer :: it
    real    :: deta, sgn_deta, eta2, eta_min, eta_max, dens1, dens2, densc, jmin, jmax, jsgn, tmp
    real    :: atol, rtol, err, err0, f, dfdj, dj, fmin, fmax, s, smin, smax

    m4_ignore(this)

    deta = dpot + delta
    eta2 = eta1 + deta

    ! get densities
    call fermi_dirac_integral_1h(eta1, dens1, tmp)
    call fermi_dirac_integral_1h(eta2, dens2, tmp)

    ! get jmin, jmax by slope (detadx must be equal to deta for some x in [0, 1])
    jmin = min(dens1, dens2) * abs(dpot - deta)
    jmax = max(dens1, dens2) * abs(dpot - deta)
    jsgn = sign(1.0, dpot - deta)
    if (jsgn < 0) then
      ! correct sign and swap jmin, jmax
      tmp  =   jmin
      jmin = - jmax
      jmax = - tmp
    end if

    ! further reduce j range if possible
    if (eta2 < eta1) then
      jmin = max(jmin, dpot * dens1)
    elseif (eta2 <= eta1 + dpot) then
      jmin = max(jmin, 0.0)
      jmax = min(jmax, dpot * dens1)
    else
      call fermi_dirac_integral_1h(eta2 - 0.5 * dpot, densc, tmp)
      jmin = max(jmin, - densc * (deta - dpot))
      jmax = min(jmax, 0.0)
    end if

    eta_min  = min(eta1, eta2)
    eta_max  = max(eta1, eta2)
    sgn_deta = sign(1.0, deta)
    deta     = abs(deta)

    xi = xi_prev
    w  = w_prev
    j  = j_prev

    if (j < jmin) j = ieee_next_after(jmin,  huge(1.0))
    if (j > jmax) j = ieee_next_after(jmax, -huge(1.0))

block
  integer, parameter :: NJ = 101
  integer :: funit, ii
  real, allocatable :: jj(:)

  jj = linspace(1000000.0, 100000000.0, NJ)

  open (newunit = funit, file = "t", status = "replace", action = "write")
  do ii = 1, NJ
    xi = xi_prev
    w  = w_prev
    j  = j_prev
    call residual(jj(ii), f, dfdj)
    stop
    write (funit, "(3ES25.16E3)") jj(ii), f, dfdj
  end do
  close (funit)
  stop

end block

    ! residuals at boundaries
    call residual(jmin, fmin, tmp)
    call residual(jmax, fmax, tmp)
    smin = sign(1.0, fmin)
    smax = sign(1.0, fmax)

    ! tolerances
    atol = max(1e-15 * (abs(j)), 1e-250)
    rtol = 1e-13
    err0 = huge(1.0)
    err  = 0.5 * (jmax - jmin)

    ! newton iteration
    it = 0
    do while ((err > atol) .and. (err > abs(j) * rtol))
      it = it + 1

      ! bisection
      if (((j < jmin) .or. (j > jmax) .or. (err0 <= err))) then
        print *, "bisection"
        j = 0.5 * (jmin + jmax)
      end if

      ! evaluate residual
      call residual(j, f, dfdj)

      ! newton update
      dj   = - f / dfdj
      err0 = err
      err  = abs(dj)

      print "(A,I6,ES25.16E3)", "outer newton: ", it, err
      print *

      ! update bounds
      s = sign(1.0, f)
      if (s * smax > 0) then
        jmax = j
        fmax = f
      else
        jmin = j
        fmin = f
      end if

      ! update solution
      j = j + dj

      ! exit if close to solution
      if (((jmax - jmin) < 0.5 * abs(jmin + jmax) * rtol) .or. (0.5 * (jmax - jmin) < atol)) then
        j = 0.5 * (jmax + jmin)
        exit
      end if
    end do

  contains

    subroutine residual(j, f, dfdj)
      real, intent(in)  :: j
      real, intent(out) :: f
      real, intent(out) :: dfdj

      integer       :: k
      real          :: dens, ddensdeta, eta, detadj, eta0, deta0dj, xi0, dxi0dj, dxidxi0(NGS), dwdxi0(NGS), ff, dffdj
      type(hp_real) :: hf

      hf   = real_to_hp(-sgn_deta)
      dfdj = 0.0

      if (j / dpot > 0) then
        call inv_fermi_dirac_integral_1h(j / dpot, eta0, deta0dj)
        deta0dj = deta0dj / dpot

        if (eta0 < eta_min) then
          xi0    = (eta_min - eta0) / deta
          dxi0dj = - deta0dj / deta
        elseif (eta0 > eta_max) then
          xi0    = (eta0 - eta_max) / deta
          dxi0dj = deta0dj / deta
        else
          print "(A,ES25.16E3)", "eta_min = ", eta_min
          print "(A,ES25.16E3)", "eta_max = ", eta_max
          print "(A,ES25.16E3)", "dpot    = ", dpot
          print "(A,ES25.16E3)", "j       = ", j
          print "(A,ES25.16E3)", "eta0    = ", eta0
          call program_error("pole within interval")
        end if

        call generate_gauss_nodes(xi0, xi, w, dxidxi0, dwdxi0)

        if (eta0 < eta_min) then
          do k = 1, NGS
            eta    = eta_min + deta * xi(k)
            detadj =           deta * dxidxi0(k) * dxi0dj
            call fermi_dirac_integral_1h(eta, dens, ddensdeta)
            tmp   = dpot - j / dens
            ff    = (eta - eta0) / tmp
            dffdj = ((detadj - deta0dj) - ff * (- 1.0 + j / dens * ddensdeta * detadj) / dens) / tmp
            ff    = w(k) * ff
            dffdj = dwdxi0(k) * dxi0dj * ff + w(k) * dffdj
            hf    = hf + ff
            dfdj  = dfdj + dffdj
          end do
        elseif (eta0 > eta_max) then
          do k = 1, NGS
            eta    = eta_max - deta * xi(k)
            detadj =         - deta * dxidxi0(k) * dxi0dj
            call fermi_dirac_integral_1h(eta, dens, ddensdeta)
            tmp = dpot - j / dens
            ff    = (eta0 - eta) / tmp
            dffdj = ((deta0dj - detadj) - ff * (- 1.0 + j / dens * ddensdeta * detadj) / dens) / tmp
            ff    = w(k) * ff
            dffdj = dwdxi0(k) * dxi0dj * ff + w(k) * dffdj
            hf    = hf + ff
            dfdj  = dfdj + dffdj
          end do
        end if
      else
        ! gauss-legendre
        xi = 0.5 * (XI_GL + 1.0)
        w  = 0.5 * W_GL
        do k = 1, NGS
          eta = eta_min + deta * xi(k)
          call fermi_dirac_integral_1h(eta, dens, tmp)
          tmp = dpot - j / dens
          ff    = deta * w(k) / tmp
          hf    = hf + ff
          dfdj  = dfdj + ff / (tmp * dens)
        end do
      end if

      f = hp_to_real(hf)
    end subroutine

  end subroutine

  subroutine generate_gauss_nodes(xi0, xi, w, dxidxi0, dwdxi0)
    real, intent(in)    :: xi0
    real, intent(inout) :: xi(:)
    real, intent(inout) :: w(:)
    real, intent(out)   :: dxidxi0(:)
    real, intent(out)   :: dwdxi0(:)

    integer       :: i, j, k
    real          :: a(NGS), b(NGS-1), z(NGS,NGS)
    type(mpfr)    :: s(0:MAXN), ds(0:MAXN), sigma(NGS,NGS+1), tmp, c1, c2

    ! evaluate moments
    call get_s(xi0, s, ds)

    call tmp%init()
    call c1%init()
    call c2%init()

    ! prepare tridiagonal matrix (modified cholesky decomposition)
    do i = 1, NGS
      do j = i, NGS + 1
        call sigma(i,j)%init_set(s(i+j-2))
        do k = 1, i-1
          ! sigma(i,j) = sigma(i,j) - sigma(k,i) * sigma(k,j) / sigma(k,k)
          call mul(tmp, sigma(k,i), sigma(k,j))
          call div(tmp, tmp, sigma(k,k))
          call sub(sigma(i,j), sigma(i,j), tmp)
        end do
      end do
    end do

    ! construct tridiagonal matrix
    ! c2 = sigma(1,2) / sigma(1,1)
    call div(c2, sigma(1,2), sigma(1,1))
    a(1) = c2%to_real()
    do i = 2, NGS
      call c1%set(c2)

      print *
      print *
      print *
      print *, c1%to_real()
      print *, c2%to_real()
      print *

      ! c2 = sigma(i,i+1) / sigma(i,i)
      call div(c2, sigma(i,i+1), sigma(i,i))

      print *
      print *, c1%to_real()
      print *, c2%to_real()
      print *
      print *
      print *

      ! a(i) = c2 - c1
      call sub(tmp, c2, c1)
      a(i) = tmp%to_real()

      ! b(i-1) = sqrt(sigma(i,i) / sigma(i-1,i-1))
      call div(tmp, sigma(i,i), sigma(i-1,i-1))
      call sqrt_mpfr(tmp, tmp)
      b(i-1) = tmp%to_real()
    end do

    do i = 1, NGS
      print "(ES24.16E3)", a(i)
    end do

    ! eigenvalues
    call stev(a, b, z)
    xi = a
    w  = z(1,:)**2

    do i = 1, NGS
      print "(2ES25.16E3)", 2*xi(i)-1, 2*w(i)
    end do





!     ! newton iteration
!     err = huge(1.0)
!     it  = 0
!     do while ((err > atol) .and. (it < 100))
!       it = it + 1
!       call get_f(xi, w, s, f, dfdx(:,0:NGS-1), dfdx(:,NGS:MAXN))

! block
!   integer :: ii
!   print *, "f = "
!   do ii = 0, size(f)-1
!     print "(ES25.16)", f(ii)
!   end do
! end block

!       call gesv(dfdx, f)
!       err = maxval(abs(f))

! block
!   integer :: ii
!   print *, "dx = "
!   do ii = 0, size(f)-1
!     print "(ES25.16)", -f(ii)
!   end do
!   stop
! end block

!       ! limit update
!       if (err > 1e-2) then
!         f = f * 1e-2 / err
!       end if
!       xil(1) = 0.5 * xi(1)
!       xir(1) = 0.5 * (xi(2) + xi(1))
!       do k = 2, NGS-1
!         xil(k) = 0.5 * (xi(k-1) + xi(k))
!         xir(k) = 0.5 * (xi(k+1) + xi(k))
!       end do
!       xil(NGS) = 0.5 * (xi(NGS-1) + xi(NGS))
!       xir(NGS) = 0.5 * (xi(NGS  ) + 1.0)
!       do k = 1, NGS
!         if (xi(k) - f(k-1) < xil(k)) f = f * (xi(k) - xil(k)) / f(k-1)
!         if (xi(k) - f(k-1) > xir(k)) f = f * (xi(k) - xir(k)) / f(k-1)
!       end do

!       xi  = xi - f(  0:NGS-1)
!       w   = w  - f(NGS:MAXN )
!       print "(A,I6,ES25.16E3)", "inner newton: ", it, err
!     end do

!     ! derivatives of xi and w wrt xi0
!     call get_f(xi, w, s, f, dfdx(:,0:NGS-1), dfdx(:,NGS:MAXN))
!     f = (- ds + ds(0) * s / s(0)) / s(0) ! df/dxi0
!     call gesv(dfdx, f)
!     dxidxi0 = - f(  0:NGS-1)
!     dwdxi0  = - f(NGS:MAXN )

  contains

    subroutine get_s(xi0, s, ds)
      real,       intent(in)  :: xi0
      type(mpfr), intent(out) :: s(0:)
      type(mpfr), intent(out) :: ds(0:)

      integer :: n

      ! fixme
      print *, "FIXME: move mpfr_startup"
      call mpfr_startup(prec = 256)

      do n = 0, MAXN
        call s( n)%init_set(1)
        call ds(n)%init_set(0)
        call div(s(n), s(n), 1 + n)
      end do
      return

      ! integer, parameter :: NP = 42

      ! integer       :: m, n
      ! type(hp_real) :: hxi, hix, hs, dhs, b, c, d

      ! if (xi0 <= 2.0) then
      !   ! hxi = (-xi0)**n
      !   ! hix = (-xi0)**(-n)
      !   ! hs, dhs: sum up to this point, derivative
      !   ! s, ds: (-xi0)**n * hs, derivative

      !   ! n = 0
      !   hxi   = real_to_hp(- xi0)
      !   hix   = 1.0 / hxi
      !   hs    = log1p(- hix)
      !   dhs   = - 1.0 / (xi0 * TwoSum(xi0, 1.0))
      !   s( 0) = hs
      !   ds(0) = dhs

      !   ! n = 1
      !   hs    = hs + hix
      !   hix   = hix / (- xi0)
      !   dhs   = dhs + hix
      !   s( 1) = hxi * hs
      !   ds(1) = - hs + hxi * dhs

      !   ! rest
      !   do n = 2, MAXN
      !     hs    = hs + hix / n
      !     hix   = hix / (- xi0)
      !     dhs   = dhs + hix
      !     ds(n) = - n * hxi * hs    ! - n * (-xi0)**(n-1) * hs
      !     hxi   = hxi * (- xi0)
      !     ds(n) = ds(n) + hxi * dhs ! - n * (-xi0)**(n-1) * hs + (-xi0)**n * dhs
      !     s( n) = hxi * hs
      !   end do
      ! else
      !   hxi = real_to_hp(xi0)
      !   hix = 1.0 / hxi
      !   s( 0) = log1p(hix)
      !   ds(0) = - 1.0 / (xi0 * (TwoSum(xi0, 1.0)))

      !   ! "Convergence Acceleration of Alternating Series", Cohen et al.
      !   d = (3.0 + sqrt(real_to_hp(8.0)))**NP
      !   d = 0.5 * (d + 1.0 / d)
      !   b = real_to_hp(- 1.0)
      !   c = - d
      !   do n = 1, MAXN
      !     s( n) = real_to_hp(0.0)
      !     ds(n) = real_to_hp(0.0)
      !   end do
      !   do m = 0, NP - 1
      !     c = b - c
      !     do n = 1, MAXN
      !       s( n) =  s(n) + c * hix / (n + m + 1)
      !     end do
      !     hix = hix / xi0
      !     do n = 1, MAXN
      !       ds(n) = ds(n) - (m + 1) * c * hix / (n + m + 1)
      !     end do
      !     b = (m + NP) * (m - NP) * b / ((m + 0.5) * (m + 1))
      !   end do
      !   do n = 1, MAXN
      !     s( n) =  s(n) / d
      !     ds(n) = ds(n) / d
      !   end do
      ! end if
    end subroutine

!     subroutine get_f(xi, w, s, f, dfdxi, dfdw)
!       real, intent(in)  :: xi(NGS)
!       real, intent(in)  :: w(NGS)
!       real, intent(in)  :: s(0:MAXN)
!       real, intent(out) :: f(0:MAXN)
!       real, intent(out) :: dfdxi(0:MAXN,NGS)
!       real, intent(out) :: dfdw( 0:MAXN,NGS)

!       integer       :: n, k
!       type(hp_real) :: hxi(NGS), hf

! print *, "s = ", s

!       hf = real_to_hp(- 1.0)
!       do k = 1, NGS
!         hf = hf + w(k)
!       end do
!       f(0) = hp_to_real(hf)
!       dfdxi(0,:) = 0
!       dfdw( 0,:) = 1

!       hf = real_to_hp(-0.5)!real_to_hp(- s(1) / s(0))
!       do k = 1, NGS
!         hf = hf + TwoProduct(w(k), xi(k))
!       end do
!       f(1) = hp_to_real(hf)
!       dfdxi(1,:) = w
!       dfdw( 1,:) = xi

!       do n = 2, MAXN
!         if (n == 2) then
!           dfdxi(n,:) = hp_to_real(2 * TwoProduct(w, xi))
!           hxi = TwoProduct(xi, xi)
!         else
!           dfdxi(n,:) = hp_to_real(n * (w * hxi))
!           hxi = hxi * xi
!         end if
!         hf = - 1.0 / real_to_hp(1.0 + n)!real_to_hp(- s(n) / s(0))
!         do k = 1, NGS
!           hf = hf + w(k) * hxi(k)
!         end do
!         f(n) = hp_to_real(hf)
!         dfdw( n,:) = hp_to_real(hxi)
!       end do
!     end subroutine

  end subroutine

  subroutine degen_table_debug(this, eta, dpot, j, x0, x1)
    class(degen_table), intent(in) :: this
    real,               intent(in) :: eta(2)
    real,               intent(in) :: dpot
    real,               intent(in) :: j
    real,               intent(in) :: x0
    real,               intent(in) :: x1

    logical           :: status
    type(ode_options) :: opt
    type(ode_result)  :: result

    m4_ignore(this)

    call opt%init(1, atol = [1e-16], rtol = [5e-15], newton_max_it = 10, max_rejected = 64, min_rx = 1e-14, initial_rx = 1e-4)
    if (x1 > x0) then
      call radau5(detadx, x0, x1, [x1], [eta(1)], [j], opt, status, result)
    else
      call radau5(detadx, x0, x1, [x1], [eta(2)], [j], opt, status, result)
    end if
    print *, status

  contains

    subroutine detadx(x, U, p, status, f, dfdU, dfdp)
      !! ode right-hand side
      real,           intent(in)  :: x
        !! x coordinate
      real,           intent(in)  :: U(:)
        !! state (eta)
      real,           intent(in)  :: p(:)
        !! parameters (j)
      logical,        intent(out) :: status
        !! success/fail
      real, optional, intent(out) :: f(:)
        !! output deta/dx
      real, optional, intent(out) :: dfdU(:,:)
        !! output derivative of f wrt eta
      real, optional, intent(out) :: dfdp(:,:)
        !! output derivative of f wrt P (ignore)

      real :: F12, dF12

      m4_ignore(x)

      status = .true.

      call fermi_dirac_integral_1h(U(1), F12, dF12)

      if (present(f)) then
        f(1) = dpot - p(1) / F12
      end if
      if (present(dfdU)) then
        dfdU(1,1) = (p(1) * dF12 / F12) / F12
      end if
      if (present(dfdp)) then
        dfdp(1,1) = - 1.0 / F12
      end if
    end subroutine

  end subroutine

end module
